{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>thutil</code> Documentation","text":""},{"location":"#thutil","title":"<code>thutil</code>","text":"<p>The package for general ulitities.</p> <p>Developed and maintained by C.Thang Nguyen</p>"},{"location":"api/","title":"API","text":""},{"location":"api/#thutil","title":"<code>thutil</code>","text":"<p>The package for general ulitities.</p> <p>Developed and maintained by C.Thang Nguyen</p> <p>Modules:</p> <ul> <li> <code>config</code>           \u2013            </li> <li> <code>io</code>           \u2013            </li> <li> <code>jobman</code>           \u2013            <p><code>jobman</code> is a job management package designed to submit and monitor jobs on remote machines. It is built on the top of the dpdispatcher package.</p> </li> <li> <code>path</code>           \u2013            </li> <li> <code>pkg</code>           \u2013            </li> <li> <code>sth2sth</code>           \u2013            </li> <li> <code>stuff</code>           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>THUTIL_ROOT</code>           \u2013            </li> <li> <code>__author__</code>           \u2013            </li> <li> <code>__contact__</code>           \u2013            </li> </ul>"},{"location":"api/#thutil.THUTIL_ROOT","title":"<code>THUTIL_ROOT = Path(__file__).parent</code>  <code>module-attribute</code>","text":""},{"location":"api/#thutil.__author__","title":"<code>__author__ = 'C.Thang Nguyen'</code>  <code>module-attribute</code>","text":""},{"location":"api/#thutil.__contact__","title":"<code>__contact__ = 'http://thangckt.github.io/email'</code>  <code>module-attribute</code>","text":""},{"location":"api/#thutil.config","title":"<code>config</code>","text":"<p>Functions:</p> <ul> <li> <code>validate_config</code>             \u2013              <p>Validate the config file with the schema file.</p> </li> <li> <code>load_config</code>             \u2013              <p>Load data from a JSON or YAML file. The YAML file can contain variable-interpolation, will be processed by OmegaConf.</p> </li> <li> <code>load_jsonc</code>             \u2013              <p>Load data from a JSON file that allow comments.</p> </li> <li> <code>unpack_dict</code>             \u2013              <p>Unpack one level of nested dictionary.</p> </li> <li> <code>write_yaml</code>             \u2013              <p>Write data to a YAML file.</p> </li> <li> <code>read_yaml</code>             \u2013              <p>Read data from a YAML file.</p> </li> </ul>"},{"location":"api/#thutil.config.validate_config","title":"<code>validate_config(config_dict=None, config_file=None, schema_dict=None, schema_file=None, allow_unknown=False, require_all=False)</code>","text":"<p>Validate the config file with the schema file.</p> <p>Parameters:</p> <ul> <li> <code>config_dict</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>config dictionary. Defaults to None.</p> </li> <li> <code>config_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>path to the YAML config file, will override <code>config_dict</code>. Defaults to None.</p> </li> <li> <code>schema_dict</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>schema dictionary. Defaults to None.</p> </li> <li> <code>schema_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>path to the YAML schema file, will override <code>schema_dict</code>. Defaults to None.</p> </li> <li> <code>allow_unknown</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>whether to allow unknown fields in the config file. Defaults to False.</p> </li> <li> <code>require_all</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>whether to require all fields in the schema file to be present in the config file. Defaults to False.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>if the config file does not match the schema</p> </li> </ul>"},{"location":"api/#thutil.config.load_config","title":"<code>load_config(filename: Union[str, Path]) -&gt; dict</code>","text":"<p>Load data from a JSON or YAML file. The YAML file can contain variable-interpolation, will be processed by OmegaConf.</p> <p>Args: filename (Union[str, Path]): The filename to load data from, whose suffix should be .json, jsonc, .yml, or .yml</p> <p>Returns:</p> <ul> <li> <code>jdata</code> (              <code>dict</code> )          \u2013            <p>(dict) The data loaded from the file</p> </li> </ul>"},{"location":"api/#thutil.config.load_jsonc","title":"<code>load_jsonc(filename: str) -&gt; dict</code>","text":"<p>Load data from a JSON file that allow comments.</p>"},{"location":"api/#thutil.config.unpack_dict","title":"<code>unpack_dict(nested_dict: dict) -&gt; dict</code>","text":"<p>Unpack one level of nested dictionary.</p>"},{"location":"api/#thutil.config.write_yaml","title":"<code>write_yaml(jdata: dict, filename: Union[str, Path])</code>","text":"<p>Write data to a YAML file.</p>"},{"location":"api/#thutil.config.read_yaml","title":"<code>read_yaml(filename: Union[str, Path]) -&gt; dict</code>","text":"<p>Read data from a YAML file.</p>"},{"location":"api/#thutil.io","title":"<code>io</code>","text":"<p>Functions:</p> <ul> <li> <code>combine_text_files</code>             \u2013              <p>Combine text files into a single file in a memory-efficient. Read and write in chunks to avoid loading large files into memory</p> </li> <li> <code>download_rawtext</code>             \u2013              <p>Download raw text from a URL.</p> </li> </ul>"},{"location":"api/#thutil.io.combine_text_files","title":"<code>combine_text_files(files: list[str], output_file: str, chunk_size: int = 1024)</code>","text":"<p>Combine text files into a single file in a memory-efficient. Read and write in chunks to avoid loading large files into memory</p> <p>Parameters:</p> <ul> <li> <code>files</code>               (<code>list[str]</code>)           \u2013            <p>List of file paths to combine.</p> </li> <li> <code>output_file</code>               (<code>str</code>)           \u2013            <p>Path to the output file.</p> </li> <li> <code>chunk_size</code>               (<code>int</code>, default:                   <code>1024</code> )           \u2013            <p>Size of each chunk in KB to read/write. Defaults to 1024 KB.</p> </li> </ul>"},{"location":"api/#thutil.io.download_rawtext","title":"<code>download_rawtext(url: str, outfile: str = None) -&gt; str</code>","text":"<p>Download raw text from a URL.</p>"},{"location":"api/#thutil.jobman","title":"<code>jobman</code>","text":"<p><code>jobman</code> is a job management package designed to submit and monitor jobs on remote machines. It is built on the top of the dpdispatcher package.</p> <p><code>jobman</code> is designed for the big data era, where the number of remoted jobs is large that handling them manually is almost impossible. Imaging that you have more than 1000 jobs to run, you have access to 3 remote high-performance computing (HPC) serves with different computing environment, and you need to monitor the progress of each job, check the output files, and download the results. This is a tedious and time-consuming task. The <code>jobman</code> package is designed to automate such tasks. <code>jobman</code> will handle the input files, submit the jobs to remote machines, monitor the progress of each job, and download the results to the local machine whenever jobs finished.</p> <p>Setting remote machines follow the remote machine schema.</p> <p>Case 1: Distribute jobs to single remote machines</p> <p>This is used for general purpose, which can define the task_list flexibly where each task can have different command_list, forward_files, backward_files. Just need to:</p> <ul> <li>Define the <code>task_list</code> as a list of Task objects.</li> <li>Use function submit_job_chunk() to submit jobs to remote machines.</li> </ul> <pre><code>from thutil.jobman import submit_job_chunk, Task\nfrom thutil.config import load_config\n\nmdict = load_config(\"remote_machine.yml\")  # load the remote machine config\ntask_list = [Task(...), Task(...), ...]    # list of Task objects\nsubmit_job_chunk(\n    mdict=mdict,\n    work_dir=work_dir,\n    task_list=task_list,\n    forward_common_files=forward_common_files,\n    backward_common_files=backward_common_files,\n)\n</code></pre> <p>Case 2: Distribute jobs to multiple remote machines</p> <p>This is used for specific purpose (e.g., <code>alff</code> package), where the jobs have the same forward_files, backward_files; but the command_list can be different based on computing environment on each remote machine. Just need to:</p> <ul> <li>Prepare the <code>task_dirs</code>, where all of them have the same forward_files, backward_files.</li> <li>Define a <code>prepare_command_list()</code> function to prepare the command_list for each remote machine.</li> </ul> <pre><code>from thutil.jobman import alff_submit_job_multi_remotes\nfrom thutil.config import load_config\nimport asyncio\n\nmdict = load_config(\"remote_machine.yml\")  # load the remote machine config\n\n### Prepare command_list on each machine\ndef prepare_command_list(machine: dict) -&gt; list:\n    command_list = []\n    dft_cmd = machine.get(\"command\", \"python\")\n    dft_cmd = f\"{dft_cmd} ../cli_gpaw_optimize.py ../{FILE_ASE_ARG}\"  # `../` to run file in common directory\n    command_list.append(dft_cmd)\n    return command_list\n\n### Submit to multiple machines\nasyncio.run(\n    alff_submit_job_multi_remotes(\n        multi_mdict=mdict,\n        prepare_command_list=prepare_command_list,\n        work_dir=work_dir,\n        task_dirs=task_dirs,\n        forward_files=forward_files,\n        backward_files=backward_files,\n        forward_common_files=forward_common_files,\n        mdict_prefix=\"dft\",\n        Logger=Logger,\n    )\n)\n</code></pre> <p>Functions:</p> <ul> <li> <code>submit_job_chunk</code>             \u2013              <p>Function to submit a jobs to the remote machine. The function will:</p> </li> <li> <code>async_submit_job_chunk</code>             \u2013              <p>Convert <code>submit_job_chunk()</code> into an async function but only need to wait for the completion of the entire <code>for</code> loop (without worrying about the specifics of each operation inside the loop)</p> </li> <li> <code>alff_submit_job_multi_remotes</code>             \u2013              <p>Submit jobs to multiple machines asynchronously.</p> </li> <li> <code>change_logpath_dispatcher</code>             \u2013              <p>Change the logfile of dpdispatcher.</p> </li> <li> <code>validate_machine_config</code>             \u2013              <p>Validate the YAML file contains machine config</p> </li> </ul>"},{"location":"api/#thutil.jobman._machine_locks","title":"<code>_machine_locks = {}</code>  <code>module-attribute</code>","text":""},{"location":"api/#thutil.jobman._DEFAULT_LOG_FILE","title":"<code>_DEFAULT_LOG_FILE = f'{time.strftime('%y%b%d_%H%M%S')}_dispatch.log'</code>  <code>module-attribute</code>","text":""},{"location":"api/#thutil.jobman._COLOR_MAP","title":"<code>_COLOR_MAP = {0: 'blue', 1: 'green', 2: 'cyan', 3: 'yellow', 4: 'red', 5: 'purple'}</code>  <code>module-attribute</code>","text":""},{"location":"api/#thutil.jobman._prepare_submission","title":"<code>_prepare_submission(mdict: dict, work_dir: str, task_list: list[Task], forward_common_files: list[str] = [], backward_common_files: list[str] = []) -&gt; Submission</code>","text":"<p>Function to simplify the preparation of the Submission object for dispatching jobs.</p>"},{"location":"api/#thutil.jobman.submit_job_chunk","title":"<code>submit_job_chunk(mdict: dict, work_dir: str, task_list: list[Task], forward_common_files: list[str] = [], backward_common_files: list[str] = [], machine_index: int = 0, Logger: object = None)</code>","text":"<p>Function to submit a jobs to the remote machine. The function will:</p> <ul> <li>Prepare the task list</li> <li>Make the submission of jobs to remote machines</li> <li>Wait for the jobs to finish and download the results to the local machine</li> </ul> <p>Parameters:</p> <ul> <li> <code>mdict</code>               (<code>dict</code>)           \u2013            <p>a dictionary contain settings of the remote machine. The parameters described in the remote machine schema. This dictionary defines the login information, resources, execution command, etc. on the remote machine.</p> </li> <li> <code>task_list</code>               (<code>list[Task]</code>)           \u2013            <p>a list of Task objects. Each task object contains the command to be executed on the remote machine, and the files to be copied to and from the remote machine. The dirs of each task must be relative to the <code>work_dir</code>.</p> </li> <li> <code>forward_common_files</code>               (<code>list[str]</code>, default:                   <code>[]</code> )           \u2013            <p>common files used for all tasks. These files are i n the <code>work_dir</code>.</p> </li> <li> <code>backward_common_files</code>               (<code>list[str]</code>, default:                   <code>[]</code> )           \u2013            <p>common files to download from the remote machine when the jobs are finished.</p> </li> <li> <code>machine_index</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>index of the machine in the list of machines.</p> </li> <li> <code>Logger</code>               (<code>object</code>, default:                   <code>None</code> )           \u2013            <p>the logger object to be used for logging.</p> </li> </ul> Note <ul> <li>Split the <code>task_list</code> into chunks to control the number of jobs submitted at once.</li> <li>Should not use the <code>Local</code> contexts, it will interference the current shell environment which leads to the unexpected behavior on local machine. Instead, use another account to connect local machine with <code>SSH</code> context.</li> </ul>"},{"location":"api/#thutil.jobman.async_submit_job_chunk","title":"<code>async_submit_job_chunk(mdict: dict, work_dir: str, task_list: list[Task], forward_common_files: list[str] = [], backward_common_files: list[str] = [], machine_index: int = 0, Logger: object = None)</code>  <code>async</code>","text":"<p>Convert <code>submit_job_chunk()</code> into an async function but only need to wait for the completion of the entire <code>for</code> loop (without worrying about the specifics of each operation inside the loop)</p> Note <ul> <li>An async function normally contain a <code>await ...</code> statement to be awaited (yield control to event loop)</li> <li>If the 'event loop is blocked' by a asynchronous function (it will not yield control to event loop), the async function will wait for the completion of the synchronous function. So, the async function will not be executed asynchronously. Try to use <code>await asyncio.to_thread()</code> to run the synchronous function in a separate thread, so that the event loop is not blocked.</li> </ul>"},{"location":"api/#thutil.jobman._get_machine_lock","title":"<code>_get_machine_lock(machine_index)</code>","text":""},{"location":"api/#thutil.jobman._run_submission_wrapper","title":"<code>_run_submission_wrapper(submission, check_interval=30, machine_index=0)</code>  <code>async</code>","text":"<p>Ensure only one instance of 'submission.run_submission' runs at a time. - If use one global lock for all machines, it will prevent concurrent execution of submissions on different machines. Therefore, each machine must has its own lock, so different machines can process jobs in parallel.</p>"},{"location":"api/#thutil.jobman._alff_prepare_task_list","title":"<code>_alff_prepare_task_list(command_list: list[str], task_dirs: list[str], forward_files: list[str], backward_files: list[str], outlog: str, errlog: str) -&gt; list[Task]</code>","text":"<p>Prepare the task list for alff package.</p> <p>The feature of jobs in <code>alff</code> package are they have the same: command_list, forward_files, backward_files. So this function is to shorthand prepare the list of Task object for <code>alff</code> package. For general usage, should prepare the task list from scratch.</p> <p>Parameters:</p> <ul> <li> <code>command_list</code>               (<code>list[str]</code>)           \u2013            <p>the list of commands to be executed on the remote machine.</p> </li> <li> <code>task_dirs</code>               (<code>list[str]</code>)           \u2013            <p>the list of directories for each task. They must be relative to the <code>work_dir</code> in function <code>_prepare_submission</code></p> </li> <li> <code>forward_files</code>               (<code>list[str]</code>)           \u2013            <p>the list of files to be copied to the remote machine. These files must existed in each <code>task_dir</code>.</p> </li> <li> <code>backward_files</code>               (<code>list[str]</code>)           \u2013            <p>the list of files to be copied back from the remote machine.</p> </li> <li> <code>outlog</code>               (<code>str</code>)           \u2013            <p>the name of the output log file.</p> </li> <li> <code>errlog</code>               (<code>str</code>)           \u2013            <p>the name of the error log file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Task]</code>           \u2013            <p>list[Task]: a list of Task objects.</p> </li> </ul>"},{"location":"api/#thutil.jobman.alff_submit_job_multi_remotes","title":"<code>alff_submit_job_multi_remotes(multi_mdict: dict, prepare_command_list: callable, work_dir: str, task_dirs: list[str], forward_files: list[str], backward_files: list[str], forward_common_files: list[str] = [], backward_common_files: list[str] = [], mdict_prefix: str = 'dft', Logger: object = None)</code>  <code>async</code>","text":"<p>Submit jobs to multiple machines asynchronously.</p> <p>Parameters:</p> <ul> <li> <code>multi_mdict</code>               (<code>dict</code>)           \u2013            <p>the big_dict contains multiple <code>mdicts</code>. Each <code>mdict</code> contains parameters of one remote machine, which parameters as in the remote machine schema.</p> </li> <li> <code>prepare_command_list(callable)</code>           \u2013            <p>a function to prepare the command list based on each remote machine.</p> </li> <li> <code>mdict_prefix(str)</code>           \u2013            <p>the prefix to select remote machines for the same purpose. Example: 'dft', 'md', 'train'.</p> </li> </ul>"},{"location":"api/#thutil.jobman.change_logpath_dispatcher","title":"<code>change_logpath_dispatcher(newlogfile: str = _DEFAULT_LOG_FILE)</code>","text":"<p>Change the logfile of dpdispatcher.</p>"},{"location":"api/#thutil.jobman._info_current_dispatch","title":"<code>_info_current_dispatch(num_tasks: int, num_tasks_current_chunk: int, job_limit, chunk_index, old_time=None, new_time=None, machine_index=0) -&gt; str</code>","text":"<p>Return the information of the current chunk of tasks.</p>"},{"location":"api/#thutil.jobman._remote_info","title":"<code>_remote_info(machine_dict) -&gt; str</code>","text":"<p>Return the remote machine information. Args:     mdict (dict): the machine dictionary</p>"},{"location":"api/#thutil.jobman._init_default_logger","title":"<code>_init_default_logger(logfile: str = _DEFAULT_LOG_FILE)</code>","text":"<p>Initialize the default logger not provided</p>"},{"location":"api/#thutil.jobman.validate_machine_config","title":"<code>validate_machine_config(machine_file: str)</code>","text":"<p>Validate the YAML file contains machine config</p>"},{"location":"api/#thutil.path","title":"<code>path</code>","text":"<p>Functions:</p> <ul> <li> <code>make_dir</code>             \u2013              <p>Create a directory with a backup option.</p> </li> <li> <code>make_dir_ask_backup</code>             \u2013              <p>Make a directory and ask for backup if the directory already exists.</p> </li> <li> <code>ask_yes_no</code>             \u2013              <p>Asks a yes/no/backup question and returns the response.</p> </li> <li> <code>list_paths</code>             \u2013              <p>List all files/folders in given directories and their subdirectories that match the given patterns.</p> </li> <li> <code>collect_files</code>             \u2013              <p>Collect files from a list of paths (files/folders). Will search files in folders and their subdirectories.</p> </li> <li> <code>change_pathname</code>             \u2013              <p>change path names</p> </li> <li> <code>remove_files</code>             \u2013              <p>Remove files from a given list of file paths.</p> </li> <li> <code>remove_dirs</code>             \u2013              <p>Remove a list of directories.</p> </li> <li> <code>remove_files_in_paths</code>             \u2013              <p>Remove files in the <code>files</code> list in the <code>paths</code> list.</p> </li> <li> <code>remove_dirs_in_paths</code>             \u2013              <p>Remove directories in the <code>dirs</code> list in the <code>paths</code> list.</p> </li> <li> <code>copy_file</code>             \u2013              <p>Copy a file/folder from the source path to the destination path.</p> </li> <li> <code>move_file</code>             \u2013              <p>Move a file/folder from the source path to the destination path.</p> </li> <li> <code>scan_dirs</code>             \u2013              <p>Check if the folders contains and not contains some files.</p> </li> </ul>"},{"location":"api/#thutil.path.make_dir","title":"<code>make_dir(path: str, backup: bool = True)</code>","text":"<p>Create a directory with a backup option.</p>"},{"location":"api/#thutil.path.make_dir_ask_backup","title":"<code>make_dir_ask_backup(dir_path: str)</code>","text":"<p>Make a directory and ask for backup if the directory already exists.</p>"},{"location":"api/#thutil.path.ask_yes_no","title":"<code>ask_yes_no(question: str) -&gt; str</code>","text":"<p>Asks a yes/no/backup question and returns the response.</p>"},{"location":"api/#thutil.path.list_paths","title":"<code>list_paths(paths: list[str], patterns: list[str], recursive=True) -&gt; list[str]</code>","text":"<p>List all files/folders in given directories and their subdirectories that match the given patterns.</p>"},{"location":"api/#thutil.path.list_paths--parameters","title":"Parameters","text":"<p>paths : list[str]     The list of paths to search files/folders. patterns : list[str]     The list of patterns to apply to the files. Each filter can be a file extension or a pattern.</p>"},{"location":"api/#thutil.path.list_paths--returns","title":"Returns:","text":"<p>List[str]: A list of matching paths.</p>"},{"location":"api/#thutil.path.list_paths--example","title":"Example:","text":"<pre><code>folders = [\"path1\", \"path2\", \"path3\"]\npatterns = [\"*.ext1\", \"*.ext2\", \"something*.ext3\", \"*folder/\"]\nfiles = list_files_in_dirs(folders, patterns)\n</code></pre>"},{"location":"api/#thutil.path.list_paths--note","title":"Note:","text":"<ul> <li>glob() does not list hidden files by default. To include hidden files, use glob(\".*\", recursive=True).</li> <li>When use recursive=True, must include <code>**</code> in the pattern to search subdirectories.<ul> <li>glob(\"*\", recursive=True) will search all FILES &amp; FOLDERS in the CURRENT directory.</li> <li>glob(\"*/\", recursive=True) will search all FOLDERS in the current CURRENT directory.</li> <li>glob(\"**\", recursive=True) will search all FILES &amp; FOLDERS in the CURRENT &amp; SUB subdirectories.</li> <li>glob(\"**/\", recursive=True) will search all FOLDERS in the current CURRENT &amp; SUB subdirectories.</li> <li>\"/*\" is equivalent to \"\".</li> <li>\"/*/\" is equivalent to \"/\".</li> </ul> </li> <li>IMPORTANT: \"/\" will replicate the behavior of \"**\", then give unexpected results.</li> </ul>"},{"location":"api/#thutil.path.collect_files","title":"<code>collect_files(paths: list[str], patterns: list[str]) -&gt; list[str]</code>","text":"<p>Collect files from a list of paths (files/folders). Will search files in folders and their subdirectories.</p>"},{"location":"api/#thutil.path.collect_files--parameters","title":"Parameters","text":"<p>paths : list[str]     The list of paths to collect files from. patterns : list[str]     The list of patterns to apply to the files. Each filter can be a file extension or a pattern.</p>"},{"location":"api/#thutil.path.collect_files--returns","title":"Returns:","text":"<p>List[str]: A list of paths matching files.</p>"},{"location":"api/#thutil.path.change_pathname","title":"<code>change_pathname(paths: list[str], old_string: str, new_string: str, replace: bool = False) -&gt; None</code>","text":"<p>change path names</p> <p>Parameters:</p> <ul> <li> <code>paths</code>               (<code>list[str]</code>)           \u2013            <p>paths to the files/dirs</p> </li> <li> <code>old_string</code>               (<code>str</code>)           \u2013            <p>old string in path name</p> </li> <li> <code>new_string</code>               (<code>str</code>)           \u2013            <p>new string in path name</p> </li> <li> <code>replace</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>replace the old path name if the new one exists. Defaults to False.</p> </li> </ul>"},{"location":"api/#thutil.path.remove_files","title":"<code>remove_files(files: list[str]) -&gt; None</code>","text":"<p>Remove files from a given list of file paths.</p> <p>Parameters:</p> <ul> <li> <code>files</code>               (<code>list[str]</code>)           \u2013            <p>list of file paths</p> </li> </ul>"},{"location":"api/#thutil.path.remove_dirs","title":"<code>remove_dirs(dirs: list[str]) -&gt; None</code>","text":"<p>Remove a list of directories.</p> <p>Parameters:</p> <ul> <li> <code>dirs</code>               (<code>list[str]</code>)           \u2013            <p>list of directories to remove.</p> </li> </ul>"},{"location":"api/#thutil.path.remove_files_in_paths","title":"<code>remove_files_in_paths(files: list, paths: list) -&gt; None</code>","text":"<p>Remove files in the <code>files</code> list in the <code>paths</code> list.</p>"},{"location":"api/#thutil.path.remove_dirs_in_paths","title":"<code>remove_dirs_in_paths(dirs: list, paths: list) -&gt; None</code>","text":"<p>Remove directories in the <code>dirs</code> list in the <code>paths</code> list.</p>"},{"location":"api/#thutil.path.copy_file","title":"<code>copy_file(src_path: str, dest_path: str)</code>","text":"<p>Copy a file/folder from the source path to the destination path.</p>"},{"location":"api/#thutil.path.move_file","title":"<code>move_file(src_path: str, dest_path: str)</code>","text":"<p>Move a file/folder from the source path to the destination path.</p>"},{"location":"api/#thutil.path.scan_dirs","title":"<code>scan_dirs(dirs: list[str], with_files: list[str], without_files: list[str] = []) -&gt; list[str]</code>","text":"<p>Check if the folders contains and not contains some files.</p> <p>Parameters:</p> <ul> <li> <code>dirs</code>               (<code>list[str]</code>)           \u2013            <p>The paths of dirs to scan.</p> </li> <li> <code>with_files</code>               (<code>list[str]</code>)           \u2013            <p>The files that should exist in the path.</p> </li> <li> <code>without_files</code>               (<code>list[str]</code>, default:                   <code>[]</code> )           \u2013            <p>The files that should not exist in the work_dir. Defaults to [].</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: The paths that meet the conditions.</p> </li> </ul>"},{"location":"api/#thutil.pkg","title":"<code>pkg</code>","text":"<p>Functions:</p> <ul> <li> <code>create_logger</code>             \u2013              <p>Create and configure a logger with console and optional file handlers.</p> </li> <li> <code>check_package</code>             \u2013              <p>Check if the required packages are installed</p> </li> <li> <code>get_func_args</code>             \u2013              <p>Get the arguments of a function</p> </li> <li> <code>dependency_info</code>             \u2013              <p>Get the dependency information</p> </li> </ul>"},{"location":"api/#thutil.pkg.create_logger","title":"<code>create_logger(logger_name: str = None, log_file: str = None, level: str = 'INFO', level_logfile: str = None, format_: str = 'info') -&gt; logging.Logger</code>","text":"<p>Create and configure a logger with console and optional file handlers.</p>"},{"location":"api/#thutil.pkg.check_package","title":"<code>check_package(package_name: str, auto_install: bool = False, git_repo: str = None, conda_channel: str = None)</code>","text":"<p>Check if the required packages are installed</p>"},{"location":"api/#thutil.pkg._install_package","title":"<code>_install_package(package_name: str, git_repo: str = None, conda_channel: str = None)</code>","text":"Install the required package <ul> <li>Default using: <code>pip install -U {package_name}</code></li> <li>If <code>git_repo</code> is provided: <code>pip install -U git+{git_repo}</code></li> <li>If <code>conda_channel</code> is provided: <code>conda install -c {conda_channel} {package_name}</code></li> </ul> <pre><code>package_name (str): package name\ngit_repo (str): git path for the package. Default: None. E.g., http://somthing.git\nconda_channel (str): conda channel for the package. Default: None. E.g., conda-forge\n</code></pre>"},{"location":"api/#thutil.pkg.get_func_args","title":"<code>get_func_args(func)</code>","text":"<p>Get the arguments of a function</p>"},{"location":"api/#thutil.pkg.dependency_info","title":"<code>dependency_info(modules=['numpy', 'polars', 'thutil', 'ase']) -&gt; str</code>","text":"<p>Get the dependency information</p>"},{"location":"api/#thutil.sth2sth","title":"<code>sth2sth</code>","text":"<p>Functions:</p> <ul> <li> <code>file2str</code>             \u2013              </li> <li> <code>str2file</code>             \u2013              </li> <li> <code>file2list</code>             \u2013              </li> <li> <code>list2file</code>             \u2013              </li> <li> <code>float2str</code>             \u2013              <p>convert float number to str</p> </li> </ul>"},{"location":"api/#thutil.sth2sth.file2str","title":"<code>file2str(file_path: Union[str, Path]) -&gt; str</code>","text":""},{"location":"api/#thutil.sth2sth.str2file","title":"<code>str2file(text: str, file_path: Union[str, Path]) -&gt; None</code>","text":""},{"location":"api/#thutil.sth2sth.file2list","title":"<code>file2list(file_path: Union[str, Path]) -&gt; list[str]</code>","text":""},{"location":"api/#thutil.sth2sth.list2file","title":"<code>list2file(text_list: list, file_path: Union[str, Path]) -&gt; None</code>","text":""},{"location":"api/#thutil.sth2sth.float2str","title":"<code>float2str(floatnum, decimals=6)</code>","text":"<p>convert float number to str REF: https://stackoverflow.com/questions/2440692/formatting-floats-without-trailing-zeros</p> <p>Parameters:</p> <ul> <li> <code>floatnum</code>               (<code>float</code>)           \u2013            <p>float number</p> </li> <li> <code>fmt</code>               (<code>str</code>)           \u2013            <p>format of the output string</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>s</code> (              <code>str</code> )          \u2013            <p>string of the float number</p> </li> </ul>"},{"location":"api/#thutil.stuff","title":"<code>stuff</code>","text":"<p>Functions:</p> <ul> <li> <code>chunk_list</code>             \u2013              <p>Yield successive n-sized chunks from <code>input_list</code>.</p> </li> <li> <code>unpack_indices</code>             \u2013              <p>Expand the input list of indices to a list of integers.</p> </li> <li> <code>text_fill_center</code>             \u2013              <p>Create a line with centered text.</p> </li> <li> <code>text_fill_left</code>             \u2013              <p>Create a line with left-aligned text.</p> </li> <li> <code>text_fill_box</code>             \u2013              <p>Put the string at the center of |  |.</p> </li> <li> <code>text_color</code>             \u2013              <p>ANSI escape codes for color the text.</p> </li> <li> <code>time_uuid</code>             \u2013              </li> <li> <code>simple_uuid</code>             \u2013              <p>Generate a simple random UUID of 4 digits.</p> </li> </ul>"},{"location":"api/#thutil.stuff.chunk_list","title":"<code>chunk_list(input_list: list, n: int) -&gt; Generator</code>","text":"<p>Yield successive n-sized chunks from <code>input_list</code>.</p>"},{"location":"api/#thutil.stuff.unpack_indices","title":"<code>unpack_indices(list_inputs: list[int | str]) -&gt; list[int]</code>","text":"<p>Expand the input list of indices to a list of integers. Eg: list_inputs = [1, 2, \"3-5:2\", \"6-10\"]</p>"},{"location":"api/#thutil.stuff.text_fill_center","title":"<code>text_fill_center(input_text='example', fill='-', max_length=60)</code>","text":"<p>Create a line with centered text.</p>"},{"location":"api/#thutil.stuff.text_fill_left","title":"<code>text_fill_left(input_text='example', left_margin=15, fill='-', max_length=60)</code>","text":"<p>Create a line with left-aligned text.</p>"},{"location":"api/#thutil.stuff.text_fill_box","title":"<code>text_fill_box(input_text='', fill=' ', sp='|', max_length=60)</code>","text":"<p>Put the string at the center of |  |.</p>"},{"location":"api/#thutil.stuff.text_color","title":"<code>text_color(text: str, color: str = 'blue') -&gt; str</code>","text":"<p>ANSI escape codes for color the text.</p>"},{"location":"api/#thutil.stuff.time_uuid","title":"<code>time_uuid() -&gt; str</code>","text":""},{"location":"api/#thutil.stuff.simple_uuid","title":"<code>simple_uuid()</code>","text":"<p>Generate a simple random UUID of 4 digits.</p>"},{"location":"config/","title":"config","text":""},{"location":"config/#thutil.config","title":"<code>thutil.config</code>","text":"<p>Functions:</p> <ul> <li> <code>validate_config</code>             \u2013              <p>Validate the config file with the schema file.</p> </li> <li> <code>load_config</code>             \u2013              <p>Load data from a JSON or YAML file. The YAML file can contain variable-interpolation, will be processed by OmegaConf.</p> </li> <li> <code>load_jsonc</code>             \u2013              <p>Load data from a JSON file that allow comments.</p> </li> <li> <code>unpack_dict</code>             \u2013              <p>Unpack one level of nested dictionary.</p> </li> <li> <code>write_yaml</code>             \u2013              <p>Write data to a YAML file.</p> </li> <li> <code>read_yaml</code>             \u2013              <p>Read data from a YAML file.</p> </li> </ul>"},{"location":"config/#thutil.config.validate_config","title":"<code>validate_config(config_dict=None, config_file=None, schema_dict=None, schema_file=None, allow_unknown=False, require_all=False)</code>","text":"<p>Validate the config file with the schema file.</p> <p>Parameters:</p> <ul> <li> <code>config_dict</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>config dictionary. Defaults to None.</p> </li> <li> <code>config_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>path to the YAML config file, will override <code>config_dict</code>. Defaults to None.</p> </li> <li> <code>schema_dict</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>schema dictionary. Defaults to None.</p> </li> <li> <code>schema_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>path to the YAML schema file, will override <code>schema_dict</code>. Defaults to None.</p> </li> <li> <code>allow_unknown</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>whether to allow unknown fields in the config file. Defaults to False.</p> </li> <li> <code>require_all</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>whether to require all fields in the schema file to be present in the config file. Defaults to False.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>if the config file does not match the schema</p> </li> </ul>"},{"location":"config/#thutil.config.load_config","title":"<code>load_config(filename: Union[str, Path]) -&gt; dict</code>","text":"<p>Load data from a JSON or YAML file. The YAML file can contain variable-interpolation, will be processed by OmegaConf.</p> <p>Args: filename (Union[str, Path]): The filename to load data from, whose suffix should be .json, jsonc, .yml, or .yml</p> <p>Returns:</p> <ul> <li> <code>jdata</code> (              <code>dict</code> )          \u2013            <p>(dict) The data loaded from the file</p> </li> </ul>"},{"location":"config/#thutil.config.load_jsonc","title":"<code>load_jsonc(filename: str) -&gt; dict</code>","text":"<p>Load data from a JSON file that allow comments.</p>"},{"location":"config/#thutil.config.unpack_dict","title":"<code>unpack_dict(nested_dict: dict) -&gt; dict</code>","text":"<p>Unpack one level of nested dictionary.</p>"},{"location":"config/#thutil.config.write_yaml","title":"<code>write_yaml(jdata: dict, filename: Union[str, Path])</code>","text":"<p>Write data to a YAML file.</p>"},{"location":"config/#thutil.config.read_yaml","title":"<code>read_yaml(filename: Union[str, Path]) -&gt; dict</code>","text":"<p>Read data from a YAML file.</p>"},{"location":"io/","title":"io","text":""},{"location":"io/#thutil.io","title":"<code>thutil.io</code>","text":"<p>Functions:</p> <ul> <li> <code>combine_text_files</code>             \u2013              <p>Combine text files into a single file in a memory-efficient. Read and write in chunks to avoid loading large files into memory</p> </li> <li> <code>download_rawtext</code>             \u2013              <p>Download raw text from a URL.</p> </li> </ul>"},{"location":"io/#thutil.io.combine_text_files","title":"<code>combine_text_files(files: list[str], output_file: str, chunk_size: int = 1024)</code>","text":"<p>Combine text files into a single file in a memory-efficient. Read and write in chunks to avoid loading large files into memory</p> <p>Parameters:</p> <ul> <li> <code>files</code>               (<code>list[str]</code>)           \u2013            <p>List of file paths to combine.</p> </li> <li> <code>output_file</code>               (<code>str</code>)           \u2013            <p>Path to the output file.</p> </li> <li> <code>chunk_size</code>               (<code>int</code>, default:                   <code>1024</code> )           \u2013            <p>Size of each chunk in KB to read/write. Defaults to 1024 KB.</p> </li> </ul>"},{"location":"io/#thutil.io.download_rawtext","title":"<code>download_rawtext(url: str, outfile: str = None) -&gt; str</code>","text":"<p>Download raw text from a URL.</p>"},{"location":"jobman/","title":"jobman","text":""},{"location":"jobman/#thutil.jobman","title":"<code>thutil.jobman</code>","text":"<p><code>jobman</code> is a job management package designed to submit and monitor jobs on remote machines. It is built on the top of the dpdispatcher package.</p> <p><code>jobman</code> is designed for the big data era, where the number of remoted jobs is large that handling them manually is almost impossible. Imaging that you have more than 1000 jobs to run, you have access to 3 remote high-performance computing (HPC) serves with different computing environment, and you need to monitor the progress of each job, check the output files, and download the results. This is a tedious and time-consuming task. The <code>jobman</code> package is designed to automate such tasks. <code>jobman</code> will handle the input files, submit the jobs to remote machines, monitor the progress of each job, and download the results to the local machine whenever jobs finished.</p> <p>Setting remote machines follow the remote machine schema.</p> <p>Case 1: Distribute jobs to single remote machines</p> <p>This is used for general purpose, which can define the task_list flexibly where each task can have different command_list, forward_files, backward_files. Just need to:</p> <ul> <li>Define the <code>task_list</code> as a list of Task objects.</li> <li>Use function submit_job_chunk() to submit jobs to remote machines.</li> </ul> <pre><code>from thutil.jobman import submit_job_chunk, Task\nfrom thutil.config import load_config\n\nmdict = load_config(\"remote_machine.yml\")  # load the remote machine config\ntask_list = [Task(...), Task(...), ...]    # list of Task objects\nsubmit_job_chunk(\n    mdict=mdict,\n    work_dir=work_dir,\n    task_list=task_list,\n    forward_common_files=forward_common_files,\n    backward_common_files=backward_common_files,\n)\n</code></pre> <p>Case 2: Distribute jobs to multiple remote machines</p> <p>This is used for specific purpose (e.g., <code>alff</code> package), where the jobs have the same forward_files, backward_files; but the command_list can be different based on computing environment on each remote machine. Just need to:</p> <ul> <li>Prepare the <code>task_dirs</code>, where all of them have the same forward_files, backward_files.</li> <li>Define a <code>prepare_command_list()</code> function to prepare the command_list for each remote machine.</li> </ul> <pre><code>from thutil.jobman import alff_submit_job_multi_remotes\nfrom thutil.config import load_config\nimport asyncio\n\nmdict = load_config(\"remote_machine.yml\")  # load the remote machine config\n\n### Prepare command_list on each machine\ndef prepare_command_list(machine: dict) -&gt; list:\n    command_list = []\n    dft_cmd = machine.get(\"command\", \"python\")\n    dft_cmd = f\"{dft_cmd} ../cli_gpaw_optimize.py ../{FILE_ASE_ARG}\"  # `../` to run file in common directory\n    command_list.append(dft_cmd)\n    return command_list\n\n### Submit to multiple machines\nasyncio.run(\n    alff_submit_job_multi_remotes(\n        multi_mdict=mdict,\n        prepare_command_list=prepare_command_list,\n        work_dir=work_dir,\n        task_dirs=task_dirs,\n        forward_files=forward_files,\n        backward_files=backward_files,\n        forward_common_files=forward_common_files,\n        mdict_prefix=\"dft\",\n        Logger=Logger,\n    )\n)\n</code></pre> <p>Functions:</p> <ul> <li> <code>submit_job_chunk</code>             \u2013              <p>Function to submit a jobs to the remote machine. The function will:</p> </li> <li> <code>async_submit_job_chunk</code>             \u2013              <p>Convert <code>submit_job_chunk()</code> into an async function but only need to wait for the completion of the entire <code>for</code> loop (without worrying about the specifics of each operation inside the loop)</p> </li> <li> <code>alff_submit_job_multi_remotes</code>             \u2013              <p>Submit jobs to multiple machines asynchronously.</p> </li> <li> <code>change_logpath_dispatcher</code>             \u2013              <p>Change the logfile of dpdispatcher.</p> </li> <li> <code>validate_machine_config</code>             \u2013              <p>Validate the YAML file contains machine config</p> </li> </ul>"},{"location":"jobman/#thutil.jobman.submit_job_chunk","title":"<code>submit_job_chunk(mdict: dict, work_dir: str, task_list: list[Task], forward_common_files: list[str] = [], backward_common_files: list[str] = [], machine_index: int = 0, Logger: object = None)</code>","text":"<p>Function to submit a jobs to the remote machine. The function will:</p> <ul> <li>Prepare the task list</li> <li>Make the submission of jobs to remote machines</li> <li>Wait for the jobs to finish and download the results to the local machine</li> </ul> <p>Parameters:</p> <ul> <li> <code>mdict</code>               (<code>dict</code>)           \u2013            <p>a dictionary contain settings of the remote machine. The parameters described in the remote machine schema. This dictionary defines the login information, resources, execution command, etc. on the remote machine.</p> </li> <li> <code>task_list</code>               (<code>list[Task]</code>)           \u2013            <p>a list of Task objects. Each task object contains the command to be executed on the remote machine, and the files to be copied to and from the remote machine. The dirs of each task must be relative to the <code>work_dir</code>.</p> </li> <li> <code>forward_common_files</code>               (<code>list[str]</code>, default:                   <code>[]</code> )           \u2013            <p>common files used for all tasks. These files are i n the <code>work_dir</code>.</p> </li> <li> <code>backward_common_files</code>               (<code>list[str]</code>, default:                   <code>[]</code> )           \u2013            <p>common files to download from the remote machine when the jobs are finished.</p> </li> <li> <code>machine_index</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>index of the machine in the list of machines.</p> </li> <li> <code>Logger</code>               (<code>object</code>, default:                   <code>None</code> )           \u2013            <p>the logger object to be used for logging.</p> </li> </ul> Note <ul> <li>Split the <code>task_list</code> into chunks to control the number of jobs submitted at once.</li> <li>Should not use the <code>Local</code> contexts, it will interference the current shell environment which leads to the unexpected behavior on local machine. Instead, use another account to connect local machine with <code>SSH</code> context.</li> </ul>"},{"location":"jobman/#thutil.jobman.async_submit_job_chunk","title":"<code>async_submit_job_chunk(mdict: dict, work_dir: str, task_list: list[Task], forward_common_files: list[str] = [], backward_common_files: list[str] = [], machine_index: int = 0, Logger: object = None)</code>  <code>async</code>","text":"<p>Convert <code>submit_job_chunk()</code> into an async function but only need to wait for the completion of the entire <code>for</code> loop (without worrying about the specifics of each operation inside the loop)</p> Note <ul> <li>An async function normally contain a <code>await ...</code> statement to be awaited (yield control to event loop)</li> <li>If the 'event loop is blocked' by a asynchronous function (it will not yield control to event loop), the async function will wait for the completion of the synchronous function. So, the async function will not be executed asynchronously. Try to use <code>await asyncio.to_thread()</code> to run the synchronous function in a separate thread, so that the event loop is not blocked.</li> </ul>"},{"location":"jobman/#thutil.jobman.alff_submit_job_multi_remotes","title":"<code>alff_submit_job_multi_remotes(multi_mdict: dict, prepare_command_list: callable, work_dir: str, task_dirs: list[str], forward_files: list[str], backward_files: list[str], forward_common_files: list[str] = [], backward_common_files: list[str] = [], mdict_prefix: str = 'dft', Logger: object = None)</code>  <code>async</code>","text":"<p>Submit jobs to multiple machines asynchronously.</p> <p>Parameters:</p> <ul> <li> <code>multi_mdict</code>               (<code>dict</code>)           \u2013            <p>the big_dict contains multiple <code>mdicts</code>. Each <code>mdict</code> contains parameters of one remote machine, which parameters as in the remote machine schema.</p> </li> <li> <code>prepare_command_list(callable)</code>           \u2013            <p>a function to prepare the command list based on each remote machine.</p> </li> <li> <code>mdict_prefix(str)</code>           \u2013            <p>the prefix to select remote machines for the same purpose. Example: 'dft', 'md', 'train'.</p> </li> </ul>"},{"location":"jobman/#thutil.jobman.change_logpath_dispatcher","title":"<code>change_logpath_dispatcher(newlogfile: str = _DEFAULT_LOG_FILE)</code>","text":"<p>Change the logfile of dpdispatcher.</p>"},{"location":"jobman/#thutil.jobman.validate_machine_config","title":"<code>validate_machine_config(machine_file: str)</code>","text":"<p>Validate the YAML file contains machine config</p>"},{"location":"path/","title":"path","text":""},{"location":"path/#thutil.path","title":"<code>thutil.path</code>","text":"<p>Functions:</p> <ul> <li> <code>make_dir</code>             \u2013              <p>Create a directory with a backup option.</p> </li> <li> <code>make_dir_ask_backup</code>             \u2013              <p>Make a directory and ask for backup if the directory already exists.</p> </li> <li> <code>ask_yes_no</code>             \u2013              <p>Asks a yes/no/backup question and returns the response.</p> </li> <li> <code>list_paths</code>             \u2013              <p>List all files/folders in given directories and their subdirectories that match the given patterns.</p> </li> <li> <code>collect_files</code>             \u2013              <p>Collect files from a list of paths (files/folders). Will search files in folders and their subdirectories.</p> </li> <li> <code>change_pathname</code>             \u2013              <p>change path names</p> </li> <li> <code>remove_files</code>             \u2013              <p>Remove files from a given list of file paths.</p> </li> <li> <code>remove_dirs</code>             \u2013              <p>Remove a list of directories.</p> </li> <li> <code>remove_files_in_paths</code>             \u2013              <p>Remove files in the <code>files</code> list in the <code>paths</code> list.</p> </li> <li> <code>remove_dirs_in_paths</code>             \u2013              <p>Remove directories in the <code>dirs</code> list in the <code>paths</code> list.</p> </li> <li> <code>copy_file</code>             \u2013              <p>Copy a file/folder from the source path to the destination path.</p> </li> <li> <code>move_file</code>             \u2013              <p>Move a file/folder from the source path to the destination path.</p> </li> <li> <code>scan_dirs</code>             \u2013              <p>Check if the folders contains and not contains some files.</p> </li> </ul>"},{"location":"path/#thutil.path.make_dir","title":"<code>make_dir(path: str, backup: bool = True)</code>","text":"<p>Create a directory with a backup option.</p>"},{"location":"path/#thutil.path.make_dir_ask_backup","title":"<code>make_dir_ask_backup(dir_path: str)</code>","text":"<p>Make a directory and ask for backup if the directory already exists.</p>"},{"location":"path/#thutil.path.ask_yes_no","title":"<code>ask_yes_no(question: str) -&gt; str</code>","text":"<p>Asks a yes/no/backup question and returns the response.</p>"},{"location":"path/#thutil.path.list_paths","title":"<code>list_paths(paths: list[str], patterns: list[str], recursive=True) -&gt; list[str]</code>","text":"<p>List all files/folders in given directories and their subdirectories that match the given patterns.</p>"},{"location":"path/#thutil.path.list_paths--parameters","title":"Parameters","text":"<p>paths : list[str]     The list of paths to search files/folders. patterns : list[str]     The list of patterns to apply to the files. Each filter can be a file extension or a pattern.</p>"},{"location":"path/#thutil.path.list_paths--returns","title":"Returns:","text":"<p>List[str]: A list of matching paths.</p>"},{"location":"path/#thutil.path.list_paths--example","title":"Example:","text":"<pre><code>folders = [\"path1\", \"path2\", \"path3\"]\npatterns = [\"*.ext1\", \"*.ext2\", \"something*.ext3\", \"*folder/\"]\nfiles = list_files_in_dirs(folders, patterns)\n</code></pre>"},{"location":"path/#thutil.path.list_paths--note","title":"Note:","text":"<ul> <li>glob() does not list hidden files by default. To include hidden files, use glob(\".*\", recursive=True).</li> <li>When use recursive=True, must include <code>**</code> in the pattern to search subdirectories.<ul> <li>glob(\"*\", recursive=True) will search all FILES &amp; FOLDERS in the CURRENT directory.</li> <li>glob(\"*/\", recursive=True) will search all FOLDERS in the current CURRENT directory.</li> <li>glob(\"**\", recursive=True) will search all FILES &amp; FOLDERS in the CURRENT &amp; SUB subdirectories.</li> <li>glob(\"**/\", recursive=True) will search all FOLDERS in the current CURRENT &amp; SUB subdirectories.</li> <li>\"/*\" is equivalent to \"\".</li> <li>\"/*/\" is equivalent to \"/\".</li> </ul> </li> <li>IMPORTANT: \"/\" will replicate the behavior of \"**\", then give unexpected results.</li> </ul>"},{"location":"path/#thutil.path.collect_files","title":"<code>collect_files(paths: list[str], patterns: list[str]) -&gt; list[str]</code>","text":"<p>Collect files from a list of paths (files/folders). Will search files in folders and their subdirectories.</p>"},{"location":"path/#thutil.path.collect_files--parameters","title":"Parameters","text":"<p>paths : list[str]     The list of paths to collect files from. patterns : list[str]     The list of patterns to apply to the files. Each filter can be a file extension or a pattern.</p>"},{"location":"path/#thutil.path.collect_files--returns","title":"Returns:","text":"<p>List[str]: A list of paths matching files.</p>"},{"location":"path/#thutil.path.change_pathname","title":"<code>change_pathname(paths: list[str], old_string: str, new_string: str, replace: bool = False) -&gt; None</code>","text":"<p>change path names</p> <p>Parameters:</p> <ul> <li> <code>paths</code>               (<code>list[str]</code>)           \u2013            <p>paths to the files/dirs</p> </li> <li> <code>old_string</code>               (<code>str</code>)           \u2013            <p>old string in path name</p> </li> <li> <code>new_string</code>               (<code>str</code>)           \u2013            <p>new string in path name</p> </li> <li> <code>replace</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>replace the old path name if the new one exists. Defaults to False.</p> </li> </ul>"},{"location":"path/#thutil.path.remove_files","title":"<code>remove_files(files: list[str]) -&gt; None</code>","text":"<p>Remove files from a given list of file paths.</p> <p>Parameters:</p> <ul> <li> <code>files</code>               (<code>list[str]</code>)           \u2013            <p>list of file paths</p> </li> </ul>"},{"location":"path/#thutil.path.remove_dirs","title":"<code>remove_dirs(dirs: list[str]) -&gt; None</code>","text":"<p>Remove a list of directories.</p> <p>Parameters:</p> <ul> <li> <code>dirs</code>               (<code>list[str]</code>)           \u2013            <p>list of directories to remove.</p> </li> </ul>"},{"location":"path/#thutil.path.remove_files_in_paths","title":"<code>remove_files_in_paths(files: list, paths: list) -&gt; None</code>","text":"<p>Remove files in the <code>files</code> list in the <code>paths</code> list.</p>"},{"location":"path/#thutil.path.remove_dirs_in_paths","title":"<code>remove_dirs_in_paths(dirs: list, paths: list) -&gt; None</code>","text":"<p>Remove directories in the <code>dirs</code> list in the <code>paths</code> list.</p>"},{"location":"path/#thutil.path.copy_file","title":"<code>copy_file(src_path: str, dest_path: str)</code>","text":"<p>Copy a file/folder from the source path to the destination path.</p>"},{"location":"path/#thutil.path.move_file","title":"<code>move_file(src_path: str, dest_path: str)</code>","text":"<p>Move a file/folder from the source path to the destination path.</p>"},{"location":"path/#thutil.path.scan_dirs","title":"<code>scan_dirs(dirs: list[str], with_files: list[str], without_files: list[str] = []) -&gt; list[str]</code>","text":"<p>Check if the folders contains and not contains some files.</p> <p>Parameters:</p> <ul> <li> <code>dirs</code>               (<code>list[str]</code>)           \u2013            <p>The paths of dirs to scan.</p> </li> <li> <code>with_files</code>               (<code>list[str]</code>)           \u2013            <p>The files that should exist in the path.</p> </li> <li> <code>without_files</code>               (<code>list[str]</code>, default:                   <code>[]</code> )           \u2013            <p>The files that should not exist in the work_dir. Defaults to [].</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: The paths that meet the conditions.</p> </li> </ul>"},{"location":"pkg/","title":"pkg","text":""},{"location":"pkg/#thutil.pkg","title":"<code>thutil.pkg</code>","text":"<p>Functions:</p> <ul> <li> <code>create_logger</code>             \u2013              <p>Create and configure a logger with console and optional file handlers.</p> </li> <li> <code>check_package</code>             \u2013              <p>Check if the required packages are installed</p> </li> <li> <code>get_func_args</code>             \u2013              <p>Get the arguments of a function</p> </li> <li> <code>dependency_info</code>             \u2013              <p>Get the dependency information</p> </li> </ul>"},{"location":"pkg/#thutil.pkg.create_logger","title":"<code>create_logger(logger_name: str = None, log_file: str = None, level: str = 'INFO', level_logfile: str = None, format_: str = 'info') -&gt; logging.Logger</code>","text":"<p>Create and configure a logger with console and optional file handlers.</p>"},{"location":"pkg/#thutil.pkg.check_package","title":"<code>check_package(package_name: str, auto_install: bool = False, git_repo: str = None, conda_channel: str = None)</code>","text":"<p>Check if the required packages are installed</p>"},{"location":"pkg/#thutil.pkg.get_func_args","title":"<code>get_func_args(func)</code>","text":"<p>Get the arguments of a function</p>"},{"location":"pkg/#thutil.pkg.dependency_info","title":"<code>dependency_info(modules=['numpy', 'polars', 'thutil', 'ase']) -&gt; str</code>","text":"<p>Get the dependency information</p>"},{"location":"sth2sth/","title":"sth2sth","text":""},{"location":"sth2sth/#thutil.sth2sth","title":"<code>thutil.sth2sth</code>","text":"<p>Functions:</p> <ul> <li> <code>file2str</code>             \u2013              </li> <li> <code>str2file</code>             \u2013              </li> <li> <code>file2list</code>             \u2013              </li> <li> <code>list2file</code>             \u2013              </li> <li> <code>float2str</code>             \u2013              <p>convert float number to str</p> </li> </ul>"},{"location":"sth2sth/#thutil.sth2sth.file2str","title":"<code>file2str(file_path: Union[str, Path]) -&gt; str</code>","text":""},{"location":"sth2sth/#thutil.sth2sth.str2file","title":"<code>str2file(text: str, file_path: Union[str, Path]) -&gt; None</code>","text":""},{"location":"sth2sth/#thutil.sth2sth.file2list","title":"<code>file2list(file_path: Union[str, Path]) -&gt; list[str]</code>","text":""},{"location":"sth2sth/#thutil.sth2sth.list2file","title":"<code>list2file(text_list: list, file_path: Union[str, Path]) -&gt; None</code>","text":""},{"location":"sth2sth/#thutil.sth2sth.float2str","title":"<code>float2str(floatnum, decimals=6)</code>","text":"<p>convert float number to str REF: https://stackoverflow.com/questions/2440692/formatting-floats-without-trailing-zeros</p> <p>Parameters:</p> <ul> <li> <code>floatnum</code>               (<code>float</code>)           \u2013            <p>float number</p> </li> <li> <code>fmt</code>               (<code>str</code>)           \u2013            <p>format of the output string</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>s</code> (              <code>str</code> )          \u2013            <p>string of the float number</p> </li> </ul>"},{"location":"stuff/","title":"stuff","text":""},{"location":"stuff/#thutil.stuff","title":"<code>thutil.stuff</code>","text":"<p>Functions:</p> <ul> <li> <code>chunk_list</code>             \u2013              <p>Yield successive n-sized chunks from <code>input_list</code>.</p> </li> <li> <code>unpack_indices</code>             \u2013              <p>Expand the input list of indices to a list of integers.</p> </li> <li> <code>text_fill_center</code>             \u2013              <p>Create a line with centered text.</p> </li> <li> <code>text_fill_left</code>             \u2013              <p>Create a line with left-aligned text.</p> </li> <li> <code>text_fill_box</code>             \u2013              <p>Put the string at the center of |  |.</p> </li> <li> <code>text_color</code>             \u2013              <p>ANSI escape codes for color the text.</p> </li> <li> <code>time_uuid</code>             \u2013              </li> <li> <code>simple_uuid</code>             \u2013              <p>Generate a simple random UUID of 4 digits.</p> </li> </ul>"},{"location":"stuff/#thutil.stuff.chunk_list","title":"<code>chunk_list(input_list: list, n: int) -&gt; Generator</code>","text":"<p>Yield successive n-sized chunks from <code>input_list</code>.</p>"},{"location":"stuff/#thutil.stuff.unpack_indices","title":"<code>unpack_indices(list_inputs: list[int | str]) -&gt; list[int]</code>","text":"<p>Expand the input list of indices to a list of integers. Eg: list_inputs = [1, 2, \"3-5:2\", \"6-10\"]</p>"},{"location":"stuff/#thutil.stuff.text_fill_center","title":"<code>text_fill_center(input_text='example', fill='-', max_length=60)</code>","text":"<p>Create a line with centered text.</p>"},{"location":"stuff/#thutil.stuff.text_fill_left","title":"<code>text_fill_left(input_text='example', left_margin=15, fill='-', max_length=60)</code>","text":"<p>Create a line with left-aligned text.</p>"},{"location":"stuff/#thutil.stuff.text_fill_box","title":"<code>text_fill_box(input_text='', fill=' ', sp='|', max_length=60)</code>","text":"<p>Put the string at the center of |  |.</p>"},{"location":"stuff/#thutil.stuff.text_color","title":"<code>text_color(text: str, color: str = 'blue') -&gt; str</code>","text":"<p>ANSI escape codes for color the text.</p>"},{"location":"stuff/#thutil.stuff.time_uuid","title":"<code>time_uuid() -&gt; str</code>","text":""},{"location":"stuff/#thutil.stuff.simple_uuid","title":"<code>simple_uuid()</code>","text":"<p>Generate a simple random UUID of 4 digits.</p>"},{"location":"schema_doc/config_remote_machine/","title":"Schema to configure remote machines","text":"<p>In the below schema, the machine and resources dicts accept all keywords as in the dpdispatcher package</p> <ul> <li>Support romote machines of various batch types: Bash, Slurm, OpenPBS, SGE, TORQUE, LSF, OpenAPI, ...</li> <li>Support various connection contexts: Local, SSH, HDFS, OpenAPI, ...</li> </ul>"},{"location":"schema_doc/config_remote_machine/#schema","title":"Schema:","text":"<pre><code>### The `machine` and `resources` dicts accept all keywords as in the dpdispatcher package\n  # machine dict: https://docs.deepmodeling.com/projects/dpdispatcher/en/latest/machine.html\n  # resources dict: https://docs.deepmodeling.com/projects/dpdispatcher/en/latest/resources.html\n\ncommon_schema: &amp;common    ### Configure remote machine\n  type: dict\n  schema:\n    machine:              ### ANCHOR: Configure parameters for login to remote machine.\n      type: dict\n      required: True\n      allow_unknown: True\n      schema:\n        batch_type:           # batch system type. Choices:'Bash' 'Slurm', 'OpenPBS', 'SGE', 'TORQUE', 'LSF', 'OpenAPI'. See more: https://docs.deepmodeling.com/projects/dpdispatcher/en/latest/batch.html\n          type: string\n        context_type:         # context type. Choices: 'Local', 'SSH', 'HDFS', 'OpenAPI'.See more: https://docs.deepmodeling.com/projects/dpdispatcher/en/latest/context.html\n          type: string\n        remote_root:          # remote root directory\n          type: string\n        remote_profile:       # profile\n          type: dict\n          schema:\n            hostname:         # hostname\n              type: string\n            username:         # username\n              type: string\n            password:         # password\n              type: string\n            port:             # port\n              type: integer\n            timeout:          # timeout\n              type: integer\n            execute_command:  # command to execute right after login\n              type: string\n\n    resources:            ### ANCHOR: Configure resources on remote machine.\n      type: dict\n      required: True\n      allow_unknown: True\n      schema:\n        number_node:          # number of nodes.\n          type: integer\n        cpu_per_node:         # number of CPUs per node.\n          type: integer\n        gpu_per_node:         # number of GPUs per node.\n          type: integer\n        custom_flags:         # list[str] of custom flags\n          type: list\n        module_list:          # list[str] of modules\n          type: list\n        source_list:          # source list[str]\n          type: list\n        envs:                 # environment variables\n          type: dict\n\n    command:              # command to execute at remote machine.\n      type: string\n    job_limit:            # maximum jobs in one submission to cluster. Default is 5.\n      type: integer\n    work_load_ratio:      # ratio of total jobs to run on this machine. If not set, all jobs will be distributed equally between all machines.\n      type: float\n\n\ntha: *common            ### ANCHOR: Configure remote machine for general purpose.\n\ntrain: *common          ### ANCHOR: Configure remote machine to run training.\n\nmd: *common             ### ANCHOR: Configure remote machine to run MD simulation.\n\ndft: *common            ### ANCHOR: Configure remote machine to run DFT calculation.\n</code></pre>"},{"location":"schema_doc/config_remote_machine/#example-configuration","title":"Example configuration:","text":"<pre><code>##### SECTION: ML training\n##### ANCHOR: SLURM - Local\ntrain_1:\n  machine:\n    batch_type: Slurm\n    context_type: SSHContext\n    remote_root: /home/tha/_job_local/train\n    remote_profile:\n      hostname: xxx.xxx.xxx.1\n      username: little_bird\n      username: some_thing\n      port: 22\n      timeout: 20\n\n  resources:\n    group_size: 1\n    number_node: 1\n    cpu_per_node: 2\n    gpu_per_node: 2\n    custom_flags:\n      - \"#SBATCH --job-name=ztr\"\n      - \"#SBATCH --time=168:00:00\"\n      - \"#SBATCH --partition=all\"       # Partition name, run `sinfo` to get a list of partitions. Use to instead of queue_name\n      # - \"#SBATCH --gres=shard:1\"\n\n      - \"source /etc/profile.d/modules.sh\"\n      - \"module use /home/tha/app/1modulefiles\"\n    module_list:\n      - conda/py12sevenn\n      # source_list:\n      #   - /etc/profile.d/modules.sh\n    envs:\n      OMP_NUM_THREADS: 1\n      OMPI_MCA_opal_cuda_support: 1\n      UCX_MEMTYPE_CACHE: n\n  # command: sevenn\n  job_limit: 1\n  work_load_ratio: 0.25  # ratio of total jobs to run on this machine.\n\n\n##### ANCHOR: SLURM - Rocky\ntrain_2:\n  machine:\n    batch_type: Slurm\n    context_type: SSHContext\n    remote_root: /home/tha/_job_rocky/train\n    remote_profile:\n      hostname: xxx.xxx.xxx.2\n      username: little_bird\n      username: some_thing\n      port: 22\n      timeout: 20\n\n  resources:\n    group_size: 1\n    number_node: 1\n    cpu_per_node: 2\n    gpu_per_node: 2\n    custom_flags:\n      - \"#SBATCH --job-name=ztr\"\n      - \"#SBATCH --time=168:00:00\"\n      - \"#SBATCH --partition=all\"       # Partition name, run `sinfo` to get a list of partitions. Use to instead of queue_name\n      # - \"#SBATCH --gres=shard:1\"\n\n      - \"source /etc/profile.d/modules.sh\"\n      - \"module use /home/tha/app/1modulefiles\"\n    module_list:\n      - conda/py12sevenn\n      # source_list:\n      #   - /etc/profile.d/modules.sh\n    envs:\n      OMP_NUM_THREADS: 1\n      OMPI_MCA_opal_cuda_support: 1\n      UCX_MEMTYPE_CACHE: n\n  # command: sevenn\n  job_limit: 1\n  work_load_ratio: 0.25 # ratio of total jobs to run on this machine.\n\n\n##### ANCHOR: SLURM - Ubuntu\ntrain_3:\n  machine:\n    batch_type: Slurm\n    context_type: SSHContext\n    remote_root: /home/tha/_job_ubuntu/train\n    remote_profile:\n      hostname: xxx.xxx.xxx.3\n      username: little_bird\n      username: some_thing\n      port: 22\n      timeout: 20\n\n  resources:\n    group_size: 1\n    number_node: 1\n    cpu_per_node: 1\n    gpu_per_node: 1\n    custom_flags:\n      - \"#SBATCH --job-name=ztr\"\n      - \"#SBATCH --time=168:00:00\"\n      # - \"#SBATCH --mem=30G\"\n      - \"#SBATCH --partition=all\"       # Partition name, run `sinfo` to get a list of partitions. Use to instead of queue_name\n      # - \"#SBATCH --gres=shard:4\"\n\n      - \"source /etc/profile.d/modules.sh\"\n      - \"module use /home/tha/app/1modulefiles\"\n    module_list:\n      - conda/py12sevenn\n    # source_list:\n      #   - /etc/profile.d/modules.sh\n    envs:\n      OMP_NUM_THREADS: 1\n      OMPI_MCA_opal_cuda_support: 1\n      UCX_MEMTYPE_CACHE: n\n  # command: sevenn\n  job_limit: 2\n  # work_load_ratio: 0.4\n##### !SECTION\n\n\n##### SECTION: MD run\n##### ANCHOR: SLURM: Local-ASE\nmd_1:\n  machine:\n    batch_type: Slurm\n    context_type: SSHContext\n    remote_root: /home/tha/_job_local/md\n    remote_profile:\n      hostname: xxx.xxx.xxx.4\n      username: little_bird\n      username: some_thing\n      port: 22\n      timeout: 20\n\n  resources:\n    group_size: 1\n    number_node: 1\n    cpu_per_node: 1\n    gpu_per_node: 1\n    custom_flags:\n      - \"#SBATCH --job-name=zmd\"\n      - \"#SBATCH --time=168:00:00\"\n      - \"#SBATCH --mem=22G\"\n      - \"#SBATCH --partition=all\"       # Partition name, run `sinfo` to get a list of partitions. Use to instead of queue_name\n      - \"#SBATCH --gres=shard:2\"\n\n      - \"source /etc/profile.d/modules.sh\"\n      - \"module use /home/tha/app/1modulefiles\"\n    module_list:\n      - conda/py12lmpSevenn\n    # source_list:\n    #   - /etc/profile.d/modules.sh\n    envs:\n      NP: $SLURM_NTASKS\n      OMP_NUM_THREADS: 1\n      OMPI_MCA_opal_cuda_support: 1\n      UCX_MEMTYPE_CACHE: n\n      # CUDA_VISIBLE_DEVICES: \"\"  # disable GPU\n  # command: \"mpirun -np $NP --allow-run-as-root lmp_mpi\"\n  job_limit: 2\n  work_load_ratio: 0.25\n\n\n##### ANCHOR: SLURM: Rocky-ASE\n### to disable GPU: `export=CUDA_VISIBLE_DEVICES=\"\"`\nmd_2:\n  machine:\n    batch_type: Slurm\n    context_type: SSHContext\n    remote_root: /home/tha/_job_rocky/md\n    remote_profile:\n      hostname: xxx.xxx.xxx.2\n      username: little_bird\n      username: some_thing\n      port: 22\n      timeout: 20\n\n  resources:\n    group_size: 1\n    number_node: 1\n    cpu_per_node: 1\n    gpu_per_node: 1\n    custom_flags:\n      - \"#SBATCH --job-name=zmd\"\n      - \"#SBATCH --time=168:00:00\"\n      - \"#SBATCH --mem=30G\"\n      - \"#SBATCH --partition=all\"       # Partition name, run `sinfo` to get a list of partitions. Use to instead of queue_name\n      - \"#SBATCH --gres=shard:2\"\n\n      - \"source /etc/profile.d/modules.sh\"\n      - \"module use /home/tha/app/1modulefiles\"\n    module_list:\n      - conda/py12lmpSevenn\n    # source_list:\n    #   - /etc/profile.d/modules.sh\n    envs:\n      NP: $SLURM_NTASKS\n      OMP_NUM_THREADS: 1\n      OMPI_MCA_opal_cuda_support: 1\n      UCX_MEMTYPE_CACHE: n\n      # CUDA_VISIBLE_DEVICES: \"\"  # disable GPU\n  # command: \"mpirun -np $NP lmp_mpi\"\n  job_limit: 2\n  work_load_ratio: 0.25  # ratio of total jobs to run on this machine.\n\n\n##### ANCHOR: SLURM: Ubuntu GPU\nmd_3:\n  machine:\n    batch_type: Slurm\n    context_type: SSHContext\n    remote_root: /home/tha/_job_ubuntu/md\n    remote_profile:\n      hostname: xxx.xxx.xxx.3\n      username: little_bird\n      username: some_thing\n      port: 22\n      timeout: 20\n\n  resources:\n    group_size: 1\n    number_node: 1\n    cpu_per_node: 1\n    gpu_per_node: 1\n    custom_flags:\n      - \"#SBATCH --job-name=zmd\"\n      - \"#SBATCH --time=168:00:00\"\n      - \"#SBATCH --mem=30G\"\n      - \"#SBATCH --partition=all\"       # Partition name, run `sinfo` to get a list of partitions. Use to instead of queue_name\n      - \"#SBATCH --gres=shard:2\"\n\n      - \"source /etc/profile.d/modules.sh\"\n      - \"module use /home/tha/app/1modulefiles\"\n    module_list:\n      - conda/py12lmpSevenn\n    # source_list:\n    #   - /etc/profile.d/modules.sh\n    envs:\n      NP: $SLURM_NTASKS\n      OMP_NUM_THREADS: 1\n      OMPI_MCA_opal_cuda_support: 1\n      UCX_MEMTYPE_CACHE: n\n      # CUDA_VISIBLE_DEVICES: \"\"  # disable GPU\n  # command: \"mpirun -np $NP lmp_mpi\"\n  job_limit: 4\n  # work_load_ratio: 0.4  # ratio of total jobs to run on this machine.\n\n\n##### ANCHOR: SGE: Centos - LAMMPS\nmd_4:\n  machine:\n    batch_type: SGE\n    context_type: SSHContext\n    remote_root: /home1/tha/_job_tachyon/md\n    remote_profile:\n      hostname: xxx.xxx.xxx.5\n      username: little_bird\n      username: some_thing\n      port: 22\n      timeout: 20\n\n  resources:\n    group_size: 1\n    queue_name: \"ib.q,1g.q\"\n    # cpu_per_node: 8\n    kwargs:\n      # pe_name: mpi_8\n      job_name: zal_md\n    custom_flags:\n      - \"#$ -l h_rt=168:00:00\"\n      # - \"#$ -l h=!(com001|com003|)\"\n    module_list:\n      - mpi/openmpi4.1.7-clang17-IB\n      - conda/py12sevenn\n      - lammps/llvmOMPI4-sevenn\n    source_list:\n      - /etc/profile.d/modules.sh\n    envs:\n      OMP_NUM_THREADS: 1\n      OMPI_MCA_btl_openib_allow_ib: 1\n\n  # command: sevenn\n  job_limit: 10\n  # work_load_ratio: 0.6\n##### !SECTION\n\n\n##### SECTION: DFT calculation\n##### ANCHOR: SLURM: Local\ndft_1:\n  machine:\n    batch_type: Slurm\n    context_type: SSHContext\n    remote_root: /home/tha/_job_local/w24_WSL_dft\n    remote_profile:\n      hostname: xxx.xxx.xxx.4\n      username: little_bird\n      username: some_thing\n      port: 22\n      timeout: 20\n\n  resources:\n    group_size: 1\n    number_node: 1\n    cpu_per_node: 1\n    gpu_per_node: 1\n    custom_flags:\n      - \"#SBATCH --job-name=zfp\"\n      - \"#SBATCH --time=168:00:00\"\n      - \"#SBATCH --mem=22G\"\n      - \"#SBATCH --partition=all\"       # Partition name, run `sinfo` to get a list of partitions. Use to instead of queue_name\n      - \"#SBATCH --gres=shard:2\"\n\n      - \"source /etc/profile.d/modules.sh\"\n      - \"module use /home/tha/app/1modulefiles\"\n    module_list:\n      - conda/py12gpaw_gpu\n    # source_list:\n    #   - /etc/profile.d/modules.sh\n    envs:\n      NP: $SLURM_NTASKS\n      OMP_NUM_THREADS: 1\n      OMPI_MCA_opal_cuda_support: 1\n      UCX_MEMTYPE_CACHE: n\n      GPAW_NEW: 1\n      GPAW_USE_GPUS: 1\n  # command: \"mpirun -np $NP --bind-to core:overload-allowed gpaw python\"\n  command: \"mpirun -np $NP gpaw python\"\n  job_limit: 2\n  work_load_ratio: 0.25  # ratio of total jobs to run on this machine.\n\n\n##### ANCHOR: SLURM: Rocky\ndft_2:\n  machine:\n    batch_type: Slurm\n    context_type: SSHContext\n    remote_root: /home/tha/_job_rocky/dft\n    remote_profile:\n      hostname: xxx.xxx.xxx.2\n      username: little_bird\n      username: some_thing\n      port: 22\n      timeout: 20\n\n  resources:\n    group_size: 1\n    number_node: 1\n    cpu_per_node: 1\n    gpu_per_node: 1\n    custom_flags:\n      - \"#SBATCH --job-name=zfp\"\n      - \"#SBATCH --time=168:00:00\"\n      - \"#SBATCH --mem=30G\"\n      - \"#SBATCH --partition=all\"       # Partition name, run `sinfo` to get a list of partitions. Use to instead of queue_name\n      - \"#SBATCH --gres=shard:2\"\n\n      - \"source /etc/profile.d/modules.sh\"\n      - \"module use /home/tha/app/1modulefiles\"\n    module_list:\n      - conda/py12gpaw_gpu\n    # source_list:\n    #   - /etc/profile.d/modules.sh\n    envs:\n      NP: $SLURM_NTASKS\n      OMP_NUM_THREADS: 1\n      OMPI_MCA_opal_cuda_support: 1\n      UCX_MEMTYPE_CACHE: n\n      GPAW_NEW: 1\n      GPAW_USE_GPUS: 1\n  command: \"mpirun -np $NP gpaw python\"\n  job_limit: 2\n  work_load_ratio: 0.25  # ratio of total jobs to run on this machine.\n\n\n##### ANCHOR: SLURM: Ubuntu GPU\ndft_3:\n  machine:\n    batch_type: Slurm\n    context_type: SSHContext\n    remote_root: /home/tha/_job_ubuntu/dft\n    remote_profile:\n      hostname: xxx.xxx.xxx.3\n      username: little_bird\n      username: some_thing\n      port: 22\n      timeout: 20\n\n  resources:\n    group_size: 1\n    number_node: 1\n    cpu_per_node: 1\n    gpu_per_node: 1\n    custom_flags:\n      - \"#SBATCH --job-name=zfp\"\n      - \"#SBATCH --time=168:00:00\"\n      - \"#SBATCH --mem=30G\"\n      - \"#SBATCH --partition=all\"       # Partition name, run `sinfo` to get a list of partitions. Use to instead of queue_name\n      - \"#SBATCH --gres=shard:2\"\n\n      - \"source /etc/profile.d/modules.sh\"\n      - \"module use /home/tha/app/1modulefiles\"\n    module_list:\n      - conda/py12gpaw_gpu\n    # source_list:\n    #   - /etc/profile.d/modules.sh\n    envs:\n      NP: $SLURM_NTASKS\n      OMP_NUM_THREADS: 1\n      OMPI_MCA_opal_cuda_support: 1\n      UCX_MEMTYPE_CACHE: n\n      GPAW_NEW: 1\n      GPAW_USE_GPUS: 1\n  command: \"mpirun -np $NP gpaw python\"\n  job_limit: 4\n  # work_load_ratio: 0.4  # ratio of total jobs to run on this machine.\n##### !SECTION\n</code></pre>"}]}